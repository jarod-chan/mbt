#mbt
  
### 目标   
* 测试mybatis相关特性
* 整合到spring框架
* 采用DDD的方式来规划项目的结构

DDD
领域驱动设计，个人理解核心是分离业务的核心设计，把它抽象到一个具体软件实现层面，而把其它的东西分离到对应的架构层次，并加以归类。

application
事务控制在这一层，简单最业务进行封装。

domain
业务核心实现，业务设计应该集中在这一种中

infrastructure
基础设施，用来支持其它层次的实现

interfaces
界面代码，提供对外访问的接口


mybatis的实现其实针对的是数据库和数据库的操作，从domian层的属性出发，应该在吧myabatis针对数据库的操作分离到infrastructure，作为对领域层的支撑。
然后在domain里用repository的特性来调用mybatis的mapper接口以及他的xml实现。
这种划分方式更符DDD的概念。


但是mybatis的mapper实现其实都是写在xml里面的，那么这个xml其实是针对数据库的代码。
如果出现业务需求变更导致需要更改数据库结构的情况，就会面对一个问题,就是不同的sql语句是存在于不同的xml文件里面的，它们需要在不同的地方分别修改。
这个违反软件设计的单一性原则。
类似jpa的orm把数据库表映射到java类的方式，就可以解决上述的问题。
一旦表结构变化，orm对应的java类也就产生变化，那么相应的关联关系上这个对象也发生了变化。
jpa的orm设计，它的出发点是基于领域的设计，用数据库来达成映射。这有一个问题，领域的设计区别很大，映射到数据的设计方式又是方式多样。
要用一个框架的设计来解决对象模型和关系模型不匹配。设计的初衷可能本身就有问题。
换个思路，domian层的设计假设是针对业务的，那么数据库层面的设计其实是属于支撑这个设计的基础设施infrastructure。也就是说，数据库只是支撑业务对象存储的一种手段。
那么orm的设计的目标应该是模拟数据库，而不是模拟业务模型。既然这样，针对不同的数据库，它的orm设计可以不一样。假设有一个新的orm框架，暂且称之为norm。
也就是说mysql存储时，使用一种模拟mysql特性的norm。这种orm针对mysql的每一种特性。比如mysql支持自增列，那么norm就应该有这种特性的面向对象设计。那orcal没有，那这种设计就不会出现。
如果按照这种方式，其实每种数据库的特性都可以在norm中实现。因为他们没有统一的接口设计，所以调用不同数据库的norm代码会不同。但是这带来的好处就是每个数据库的特性和性能反而可以完全发挥。
可能会产生的问题就是不同数据库的迁移。这个问题很好解决，因为我们在domain层有了一个repository接口。它就可以屏蔽norm不同数据库的不同代码。
（如果把repository的接口放在domain层，而实现方在infrastructure层的话，那么我们在切换数据库造成的代码变更，可以很好的只存在infrastructure这一层）
考虑到sql在不同数据库上的通用性，自然这种norm在设计及实现方式上，也可以保持一定的通用性。
即使我们不采用数据库，而采用nosql数据库或者文件来存储你的信息。也同样可以在这一层的做。也就是说它还是符合本身的职责划分的。


采用mybatis时，其实很多实现都在xml里面，感觉repository有点重复实现的迹象，在加上service，几个接口有点重复。
